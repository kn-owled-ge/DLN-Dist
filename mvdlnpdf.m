function p = mvdlnpdf(W,MU,SIG,muDLN,sigDLN,rhoDLN)
% P = MVDLNPDF(W,MU,SIG,muDLN,sigDLN,rhoDLN) returns the pdf of the 
% multi-variate DLN with location MU and scale SIG, generated by the 
% SymDLN(muDLN,sigDLN,rhoDLN). W[NxK] is N-dimensional DLN with K
% observations.
%
% For theoretical derivation, see Parham (2022)

% Check parameters
N = size(W,1);
if nargin==1
   MU     = zeros(N,1);
   SIG    = eye(N);
   muDLN  = 0;
   sigDLN = 1;
   rhoDLN = 0;
elseif nargin==3
   muDLN  = 0;
   sigDLN = 1;
   rhoDLN = 0;
elseif nargin~=6
    error('stats:DLN:BadInputs','Requires 1, 3, or 6 input arguments.');
end
if (N<2)
   error('stats:DLN:BadInputs','Expected size(X)=[N,K] with N>=2');
end
if (any(size(MU)~=[N 1]) || any(size(SIG)~=[N N]))
   error('stats:DLN:BadInputs','Expected size(MU)=[N 1] and size(SIG)=[N N]');
end
if ~isscalar(muDLN) || ~isscalar(sigDLN) || ~isscalar(rhoDLN) 
   error('stats:DLN:BadInputs','Expected size(muDLN,sigDLN,rhoDLN)=[1,1]');
end
if sigDLN <= 0 || abs(rhoDLN) >= 1
   error('stats:DLN:BadInputs','Expected sigDLN>0, abs(rDLN)<1');
end


% Get R, the euclidean norm of W under SIG
Wm = W-MU;
R  = sqrt(sum(Wm.*(SIG\Wm)));

% Plug to the generator function
G = GEN_MVDLN(R,muDLN,sigDLN,rhoDLN,N);

% Return result
p = det(SIG)^(-0.5)*G;

end



% Generator function for the MVDLN based on SymDLN(muDLN,sigDLN,rhoDLN)
function gen = GEN_MVDLN(R,muDLN,sigDLN,rhoDLN,N)
   persistent Ist
   if (isempty(Ist) || any(abs([Ist.muDLN Ist.sigDLN Ist.rhoDLN Ist.N]-[muDLN sigDLN rhoDLN N])>1E-3)) 
      Ist.muDLN  = muDLN;
      Ist.sigDLN = sigDLN;
      Ist.rhoDLN = rhoDLN;
      Ist.N      = N;
      r_1        = sinh(1:1:30);
      v_1        = r_1.^(N-1).*dlnpdf(r_1,muDLN,sigDLN,muDLN,sigDLN,rhoDLN);
      i_H = find(v_1==0,1,'first');
      if isempty(i_H)
         i_H=numel(v_1);
      end
      Ist.Int    = integral(@(r_) r_.^(N-1).*dlnpdf(r_,muDLN,sigDLN,muDLN,sigDLN,rhoDLN),0,r_1(i_H),'RelTol',1e-8,'AbsTol',1e-10);
   end
   gen = gamma(N/2)*dlnpdf(R,muDLN,sigDLN,muDLN,sigDLN,rhoDLN)/(Ist.Int*2.*pi^(N/2));
end
